1. Просмотреть содержимое директорий /etc, /proc, /home. Посмотреть содержимое пары произвольных файлов в /etc.
$ ls /etc
$ ls /proc
$ ls /home
$ cat /etc/hosts
$ cat /etc/passwd

2. Выяснить, для чего предназначена команда cat. Используя только данную команду и потоки ввода-вывода:
- создайте два файла с данными, а затем объедините их в один.
$ cat > file1
text1
ctrl+d

$ cat > file2
text2
ctrl+d

$ cat file1 file2 > file3

- просмотрите содержимое созданного файла.
$ cat file3

- скопируйте файл, дав ему новое имя.
$ cat file3 > file4

3. Создать 3 новых файла 3-мя разными способами.
$ touch file5
$ echo "" > file6
$ cat > file7

Создайте директорию, переместите файл туда.
$ mkdir new_dir
$ mv file5 file6 file7 new_dir/

Удалите все созданные в этом и предыдущем задании директории и файлы.
$ rm file*
$ rm -r new_dir

4. В ОС Linux скрытыми файлами считаются те, имена которых начинаются с символа точки .. Напишите команду, которая будет показывать количество скрытых файлов в домашнем каталоге пользоватедя. При Использовать конвейер (пайплайн). Подсказка: для подсчета количества строк можно использовать wc).
$ ls -A ~/ | egrep ^[.*] | wc -l

5. Попробовать вывести с помощью команды cat содержимое всех файлов в директории /etc, перенаправив вывод в любой файл в директории /tmp, а ошибки в отдельный файл в домашнем каталоге. Использовать вайлдкарты. Сколько файлов, которые не удалось посмотреть, оказалось в списке?
$ cat /etc/* 1> /tmp/test/result.txt 2> /tmp/test/error.txt

6. Используя справку команды ps, разберитесь как вывести информацию о процессах в древовидной форме, как вывести процессы, запущенные только пользователем gdm, как узнать PID процесса.
Древовидная форма:
$ ps axjf
Процессы, запущенные только пользователем gdm:
$ ps aux | egrep ^gdm
или
$ ps -fu gdm

Узнаём PID процесса, например, cron следующим образом:
фильтруем вывод команды ps aux по названию процесса, затем исключаем из вывода процесс grep
$ ps aux | grep cron | grep -v grep
или
$ ps -A | grep cron

Если не нужно видеть подробную информацию о процессе, а достаточно только PID, то можно использовать команду pgrep:
$ pgrep cron

7. Прочитать в методическом пособии о сигналах.
Запустить в одном терминале любую программу, например vim.
$ vim
В другом терминале посмотреть PID процесса.
$ ps aux | grep vim | grep -v grep
PID процесса: 2221

Остановить с помощью kill, посылая разные типы сигналов (SIGHUP, SIGTERM, SIGSEGV, SIGILL). Чем отличается заверщение программы в зависимости от сигнала?

SIGHUP
$ kill -1 2221
Vim: Caught deadly signal HUP
Vim: Finished.
Hangup

Запускаем vim заново, смотрим новый PID.
SIGTERM
$ kill -15 2331
Vim: Caught deadly signal TERM
Vim: Finished.
Terminated

Запускаем vim заново, смотрим новый PID.
SIGSEGV
$ kill -11 2338
Vim: Caught deadly signal SEGV
Vim: Finished.
Segmentation fault (core dumped) - создан файл с именем core, содержащий образ памяти процесса, когда он получил сигнал.

Запускаем vim заново, смотрим новый PID.
SIGILL
$ kill -4 2349
Vim: Caught deadly signal ILL
Vim: Finished.
Illegal instruction (core dumped) - создан файл с именем core, содержащий образ памяти процесса, когда он получил сигнал.


